package org.codefilarete.jumper.schema;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.BiPredicate;

import org.codefilarete.jumper.schema.SchemaElementCollector.Schema;
import org.codefilarete.jumper.schema.SchemaElementCollector.Schema.AscOrDesc;
import org.codefilarete.jumper.schema.SchemaElementCollector.Schema.Index;
import org.codefilarete.jumper.schema.SchemaElementCollector.Schema.Table;
import org.codefilarete.jumper.schema.SchemaElementCollector.Schema.Table.Column;
import org.codefilarete.jumper.schema.SchemaElementCollector.Schema.Table.ForeignKey;
import org.codefilarete.jumper.schema.SchemaElementCollector.Schema.View;
import org.codefilarete.jumper.schema.SchemaElementCollector.Schema.View.PseudoColumn;
import org.codefilarete.stalactite.sql.UrlAwareDataSource;
import org.codefilarete.stalactite.sql.test.HSQLDBInMemoryDataSource;
import org.codefilarete.tool.collection.Iterables;
import org.codefilarete.tool.function.Predicates;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

class SchemaElementCollectorTest {
	
	@Test
	void build_tables() throws SQLException {
		
		UrlAwareDataSource dataSourceReference = new HSQLDBInMemoryDataSource();
		Connection connection = dataSourceReference.getConnection();
		connection.prepareStatement("create table A(id BIGINT generated by default as identity, name VARCHAR(200) not null, age float, primary key (id));").execute();
		connection.prepareStatement("create table B(id BIGINT, aId BIGINT, dummyData VARCHAR(50), primary key (id));").execute();
		connection.commit();
		
		SchemaElementCollector testInstance = new SchemaElementCollector(dataSourceReference.getConnection().getMetaData());
		Schema schema = testInstance.withCatalog(null)
				.withSchema(null)
				.withTableNamePattern("%")
				.collect();
		
		Schema expectedResult = new Schema(null);
		Table tableA = expectedResult.addTable("A");
		Column columnA_Id = tableA.addColumn("ID", "BIGINT", 64, 0, false, true);
		Column columnA_name = tableA.addColumn("NAME", "VARCHAR", 200, null, false, false);
		Column columnA_age = tableA.addColumn("AGE", "DOUBLE", 64, null, true, false);
		tableA.setPrimaryKey(Arrays.asList(columnA_Id));
		
		Table tableB = expectedResult.addTable("B");
		Column columnB_Id = tableB.addColumn("ID", "BIGINT", 64, 0, false, false);
		Column columnB_aId = tableB.addColumn("AID", "BIGINT", 64, 0, true, false);
		Column columnB_dummyData = tableB.addColumn("DUMMYDATA", "VARCHAR", 50, 0, false, false);
		tableB.setPrimaryKey(Arrays.asList(columnB_Id));
		tableB.addForeignKey("FROMBTOA", Arrays.asList(columnB_aId), tableA, Arrays.asList(columnA_Id));
		
		Index indexToto = expectedResult.new Index("TOTO");
		indexToto.setUnique(true);
		indexToto.addColumn(columnA_name, AscOrDesc.ASC);
		
		BiPredicate<Table, Table> tableNamespacePredicate = Predicates.and(Table::getName, table -> table.getSchema().getName());
		BiPredicate<Column, Column> columnPredicate = Predicates.and(Column::getName, Column::getType, Column::getSize)
				.and((c1, c2) -> tableNamespacePredicate.test(c1.getTable(), c2.getTable()));
		java.util.Comparator<Column> columnComparator = Predicates.toComparator(columnPredicate);
		
		// Checking Table columns, primary key, and other simple attributes
		Map<String, Table> tablePerName = Iterables.map(schema.getTables(), Table::getName);
		Table actualTableA = tablePerName.get("A");
		assertThat(actualTableA.getName()).isEqualTo(tableA.getName());
		assertThat(actualTableA.getComment()).isEqualTo(tableA.getComment());
		assertThat(actualTableA.getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableA.getColumns());
		assertThat(actualTableA.getPrimaryKey().getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableA.getPrimaryKey().getColumns());
		
		Table actualTableB = tablePerName.get("B");
		assertThat(actualTableB.getName()).isEqualTo(tableB.getName());
		assertThat(actualTableB.getComment()).isEqualTo(tableB.getComment());
		assertThat(actualTableB.getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableB.getColumns());
		assertThat(actualTableB.getPrimaryKey().getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableB.getPrimaryKey().getColumns());
		
		assertThat(schema.getTables()).hasSize(2);
	}
		
	@Test
	void build_foreignkeys() throws SQLException {
		
		UrlAwareDataSource dataSourceReference = new HSQLDBInMemoryDataSource();
		Connection connection = dataSourceReference.getConnection();
		connection.prepareStatement("create table A(id BIGINT generated by default as identity, primary key (id));").execute();
		connection.prepareStatement("create table B(id BIGINT, aId BIGINT, primary key (id), constraint fromBtoA foreign key (aId) references A(id));").execute();
		connection.commit();
		
		SchemaElementCollector testInstance = new SchemaElementCollector(dataSourceReference.getConnection().getMetaData());
		Schema schema = testInstance.withCatalog(null)
				.withSchema(null)
				.withTableNamePattern("%")
				.collect();
		
		Schema expectedResult = new Schema(null);
		Table tableA = expectedResult.addTable("A");
		Column columnA_Id = tableA.addColumn("ID", "BIGINT", 64, 0, false, true);
		tableA.setPrimaryKey(Arrays.asList(columnA_Id));
		
		Table tableB = expectedResult.addTable("B");
		Column columnB_Id = tableB.addColumn("ID", "BIGINT", 64, 0, false, false);
		Column columnB_aId = tableB.addColumn("AID", "BIGINT", 64, 0, true, false);
		tableB.setPrimaryKey(Arrays.asList(columnB_Id));
		tableB.addForeignKey("FROMBTOA", Arrays.asList(columnB_aId), tableA, Arrays.asList(columnA_Id));
		
		BiPredicate<Table, Table> tableNamespacePredicate = Predicates.and(Table::getName, table -> table.getSchema().getName());
		BiPredicate<Column, Column> columnPredicate = Predicates.and(Column::getName, Column::getType, Column::getSize)
				.and((c1, c2) -> tableNamespacePredicate.test(c1.getTable(), c2.getTable()));
		java.util.Comparator<Column> columnComparator = Predicates.toComparator(columnPredicate);
		
		// Checking Table columns, primary key, and other simple attributes
		Map<String, Table> tablePerName = Iterables.map(schema.getTables(), Table::getName);
		Table actualTableB = tablePerName.get("B");
		
		// Checking foreign keys
		Map<String, ForeignKey> actualForeignKeyPerName = Iterables.map(actualTableB.getForeignKeys(), ForeignKey::getName);
		ForeignKey actualForeignKeyFromBtoA = actualForeignKeyPerName.get("FROMBTOA");
		Map<String, ForeignKey> currentForeignKeyPerName = Iterables.map(tableB.getForeignKeys(), ForeignKey::getName);
		ForeignKey currentForeignKeyFromBtoA = currentForeignKeyPerName.get("FROMBTOA");
		assertThat(actualForeignKeyFromBtoA.getName()).isEqualTo(currentForeignKeyFromBtoA.getName());
		assertThat(actualForeignKeyFromBtoA.getColumns())
				.usingElementComparator(columnComparator)
				.containsExactlyElementsOf(actualForeignKeyFromBtoA.getColumns());
		assertThat(actualForeignKeyFromBtoA.getTargetTable())
				.usingComparator(Predicates.toComparator(tableNamespacePredicate))
				.isEqualTo(actualForeignKeyFromBtoA.getTargetTable());
		assertThat(actualForeignKeyFromBtoA.getTargetColumns())
				.usingElementComparator(columnComparator)
				.containsExactlyElementsOf(actualForeignKeyFromBtoA.getTargetColumns());
	}
	
	@Test
	void build_indexes() throws SQLException {
		
		UrlAwareDataSource dataSourceReference = new HSQLDBInMemoryDataSource();
		Connection connection = dataSourceReference.getConnection();
		connection.prepareStatement("create table A(id BIGINT generated by default as identity, name VARCHAR(200) not null, age float, primary key (id));").execute();
		connection.prepareStatement("create unique index toto on A(name asc);").execute();
		connection.commit();
		
		SchemaElementCollector testInstance = new SchemaElementCollector(dataSourceReference.getConnection().getMetaData());
		Schema schema = testInstance.withCatalog(null)
				.withSchema(null)
				.withTableNamePattern("%")
				.collect();
	
		Schema expectedResult = new Schema(null);
		Table tableA = expectedResult.addTable("A");
		Column columnA_Id = tableA.addColumn("ID", "BIGINT", 64, 0, false, true);
		Column columnA_name = tableA.addColumn("NAME", "VARCHAR", 200, null, false, false);
		Column columnA_age = tableA.addColumn("AGE", "DOUBLE", 64, null, true, false);
		tableA.setPrimaryKey(Arrays.asList(columnA_Id));
		
		Index indexToto = expectedResult.new Index("TOTO");
		indexToto.setUnique(true);
		indexToto.addColumn(columnA_name, AscOrDesc.ASC);
		
		// Checking indexes
		Map<String, Index> indexPerName = Iterables.map(schema.getIndexes(), Index::getName);
		Index actualIndexToto = indexPerName.get("TOTO");
		assertThat(actualIndexToto.getName()).isEqualTo(indexToto.getName());
		assertThat(actualIndexToto.isUnique()).isEqualTo(indexToto.isUnique());
		
		// Checking columns
		BiPredicate<Table, Table> tableNamespacePredicate = Predicates.and(Table::getName, table -> table.getSchema().getName());
		BiPredicate<Column, Column> columnPredicate = Predicates.and(Column::getName, Column::getType, Column::getSize)
				.and((c1, c2) -> tableNamespacePredicate.test(c1.getTable(), c2.getTable()));
		BiPredicate<Map.Entry<Column, AscOrDesc>, Map.Entry<Column, AscOrDesc>> columnKeyPredicate = (entry1, entry2) -> columnPredicate.test(entry1.getKey(), entry2.getKey());
		columnKeyPredicate = columnKeyPredicate.and(Predicates.and(Entry::getValue));
		assertThat(actualIndexToto.getColumns().entrySet())
				.usingElementComparator(Predicates.toComparator(columnKeyPredicate.and(Predicates.and(Entry::getValue))))
				.containsExactlyElementsOf(indexToto.getColumns().entrySet());
	}
	
	@Test
	void build_views() throws SQLException {
		
		UrlAwareDataSource dataSourceReference = new HSQLDBInMemoryDataSource();
		Connection connection = dataSourceReference.getConnection();
		connection.prepareStatement("create table A(id BIGINT generated by default as identity, name VARCHAR(200) not null, age float, primary key (id));").execute();
		connection.prepareStatement("create table B(id BIGINT, aId BIGINT, dummyData VARCHAR(50), primary key (id), constraint fromBtoA foreign key (aId) references A(id));").execute();
		connection.prepareStatement("create view DummyView as select a.id as x, a.name, b.dummyData from A a inner join B b on a.id = b.aId;").execute();
		connection.commit();
		
		SchemaElementCollector testInstance = new SchemaElementCollector(dataSourceReference.getConnection().getMetaData());
		Schema schema = testInstance.withCatalog(null)
				.withSchema(null)
				.withTableNamePattern("%")
				.collect();
	
		// Checking views
		Schema expectedResult = new Schema(null);
		View tutuView = expectedResult.addView("DUMMYVIEW");
		tutuView.addColumn("X", "BIGINT", 64, 0, true)
				// note that NAME column is nullable in view whereas it's not in original table
				.addColumn("NAME", "VARCHAR", 200, null, true)
				.addColumn("DUMMYDATA", "VARCHAR", 50, null, true);
		
		Map<String, View> viewPerName = Iterables.map(schema.getViews(), View::getName);
		View actualView = viewPerName.get("DUMMYVIEW");
		assertThat(actualView.getName()).isEqualTo(tutuView.getName());
		
		BiPredicate<PseudoColumn, PseudoColumn> columnPredicate = Predicates.and(PseudoColumn::getName, PseudoColumn::getType,
						PseudoColumn::getSize, PseudoColumn::getPrecision, PseudoColumn::isNullable);
		java.util.Comparator<PseudoColumn> columnComparator = Predicates.toComparator(columnPredicate);
		assertThat(actualView.getColumns())
				.usingElementComparator(columnComparator)
				.containsExactlyElementsOf(tutuView.getColumns());
	}
	
	@Test
	void build() throws SQLException {
		
		DataSource dataSourceReference = new HSQLDBInMemoryDataSource();
		Connection connection = dataSourceReference.getConnection();
		connection.prepareStatement("create table A(id BIGINT generated by default as identity, name VARCHAR(200) not null, age float, primary key (id));").execute();
		connection.prepareStatement("create table B(id BIGINT, aId BIGINT, dummyData VARCHAR(50), primary key (id), constraint fromBtoA foreign key (aId) references A(id));").execute();
		connection.prepareStatement("create unique index toto on A(name asc);").execute();
		connection.prepareStatement("create view TUTU as select a.id, a.name, b.dummyData from A a inner join B b on a.id = b.aId;").execute();
		connection.commit();
		
		SchemaElementCollector testInstance = new SchemaElementCollector(dataSourceReference.getConnection().getMetaData());
		testInstance.withCatalog(null)
				.withSchema(null)
				.withTableNamePattern("%");
		Schema schema = testInstance.collect();
	
		Schema expectedResult = new Schema(null);
		Table tableA = expectedResult.addTable("A");
		Column columnA_Id = tableA.addColumn("ID", "BIGINT", 64, 0, false, true);
		Column columnA_name = tableA.addColumn("NAME", "VARCHAR", 200, null, false, false);
		Column columnA_age = tableA.addColumn("AGE", "DOUBLE", 64, null, true, false);
		tableA.setPrimaryKey(Arrays.asList(columnA_Id));
		
		Table tableB = expectedResult.addTable("B");
		Column columnB_Id = tableB.addColumn("ID", "BIGINT", 64, 0, false, false);
		Column columnB_aId = tableB.addColumn("AID", "BIGINT", 64, 0, true, false);
		Column columnB_dummyData = tableB.addColumn("DUMMYDATA", "VARCHAR", 50, 0, false, false);
		tableB.setPrimaryKey(Arrays.asList(columnB_Id));
		tableB.addForeignKey("FROMBTOA", Arrays.asList(columnB_aId), tableA, Arrays.asList(columnA_Id));
		
		Index indexToto = expectedResult.new Index("TOTO");
		indexToto.setUnique(true);
		indexToto.addColumn(columnA_name, AscOrDesc.ASC);
		
		assertThat(schema.getName()).isNull();
		
		BiPredicate<Table, Table> tableNamespacePredicate = Predicates.and(Table::getName, table -> table.getSchema().getName());
		BiPredicate<Column, Column> columnPredicate = Predicates.and(Column::getName, Column::getType, Column::getSize)
				.and((c1, c2) -> tableNamespacePredicate.test(c1.getTable(), c2.getTable()));
		java.util.Comparator<Column> columnComparator = Predicates.toComparator(columnPredicate);
		
		// Checking Table columns, primary key, and other simple attributes
		Map<String, Table> tablePerName = Iterables.map(schema.getTables(), Table::getName);
		Table actualTableA = tablePerName.get("A");
		assertThat(actualTableA.getName()).isEqualTo(tableA.getName());
		assertThat(actualTableA.getComment()).isEqualTo(tableA.getComment());
		assertThat(actualTableA.getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableA.getColumns());
		assertThat(actualTableA.getPrimaryKey().getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableA.getPrimaryKey().getColumns());
		
		Table actualTableB = tablePerName.get("B");
		assertThat(actualTableB.getName()).isEqualTo(tableB.getName());
		assertThat(actualTableB.getComment()).isEqualTo(tableB.getComment());
		assertThat(actualTableB.getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableB.getColumns());
		assertThat(actualTableB.getPrimaryKey().getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableB.getPrimaryKey().getColumns());
		
		assertThat(schema.getTables()).hasSize(2);
		
		// Checking foreign keys
		Map<String, ForeignKey> actualForeignKeyPerName = Iterables.map(actualTableB.getForeignKeys(), ForeignKey::getName);
		ForeignKey actualForeignKeyFromBtoA = actualForeignKeyPerName.get("FROMBTOA");
		Map<String, ForeignKey> currentForeignKeyPerName = Iterables.map(tableB.getForeignKeys(), ForeignKey::getName);
		ForeignKey currentForeignKeyFromBtoA = currentForeignKeyPerName.get("FROMBTOA");
		assertThat(actualForeignKeyFromBtoA.getName()).isEqualTo(currentForeignKeyFromBtoA.getName());
		assertThat(actualForeignKeyFromBtoA.getColumns())
				.usingElementComparator(columnComparator)
				.containsExactlyElementsOf(actualForeignKeyFromBtoA.getColumns());
		assertThat(actualForeignKeyFromBtoA.getTargetTable())
				.usingComparator(Predicates.toComparator(tableNamespacePredicate))
				.isEqualTo(actualForeignKeyFromBtoA.getTargetTable());
		assertThat(actualForeignKeyFromBtoA.getTargetColumns())
				.usingElementComparator(columnComparator)
				.containsExactlyElementsOf(actualForeignKeyFromBtoA.getTargetColumns());
		
		// Checking indexes
		BiPredicate<Map.Entry<Column, AscOrDesc>, Map.Entry<Column, AscOrDesc>> columnKeyPredicate = (entry1, entry2) -> columnPredicate.test(entry1.getKey(), entry2.getKey());
		columnKeyPredicate = columnKeyPredicate.and(Predicates.and(Entry::getValue));
		Map<String, Index> indexPerName = Iterables.map(schema.getIndexes(), Index::getName);
		Index actualIndexToto = indexPerName.get("TOTO");
		assertThat(actualIndexToto.getName()).isEqualTo(indexToto.getName());
		assertThat(actualIndexToto.isUnique()).isEqualTo(indexToto.isUnique());
		assertThat(actualIndexToto.getColumns().entrySet())
				.usingElementComparator(Predicates.toComparator(columnKeyPredicate.and(Predicates.and(Entry::getValue))))
				.containsExactlyElementsOf(indexToto.getColumns().entrySet());
	}
}