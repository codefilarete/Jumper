package org.codefilarete.jumper.schema;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.codefilarete.jumper.schema.SchemaBuilder.Schema;
import org.codefilarete.jumper.schema.SchemaBuilder.Schema.AscOrDesc;
import org.codefilarete.jumper.schema.SchemaBuilder.Schema.Index;
import org.codefilarete.jumper.schema.SchemaBuilder.Schema.Table;
import org.codefilarete.jumper.schema.SchemaBuilder.Schema.Table.Column;
import org.codefilarete.jumper.schema.SchemaBuilder.Schema.Table.ForeignKey;
import org.codefilarete.jumper.schema.SchemaBuilder.Schema.View;
import org.codefilarete.jumper.schema.SchemaBuilder.Schema.View.PseudoColumn;
import org.codefilarete.jumper.schema.SchemaBuilderTest.ComparisonChain.PropertyComparator;
import org.codefilarete.jumper.schema.SchemaBuilderTest.ComparisonChain.PropertyComparator.PropertyDiff;
import org.codefilarete.jumper.schema.difference.AbstractDiff;
import org.codefilarete.jumper.schema.difference.CollectionDiffer;
import org.codefilarete.jumper.schema.difference.Diff;
import org.codefilarete.jumper.schema.difference.IndexedDiff;
import org.codefilarete.jumper.schema.difference.ListDiffer;
import org.codefilarete.jumper.schema.difference.SetDiffer;
import org.codefilarete.jumper.schema.difference.State;
import org.codefilarete.reflection.AccessorByMethodReference;
import org.codefilarete.reflection.AccessorDefinition;
import org.codefilarete.stalactite.sql.UrlAwareDataSource;
import org.codefilarete.stalactite.sql.test.HSQLDBInMemoryDataSource;
import org.codefilarete.tool.collection.Iterables;
import org.codefilarete.tool.collection.KeepOrderSet;
import org.codefilarete.tool.function.Predicates;
import org.danekja.java.util.function.serializable.SerializableFunction;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

class SchemaBuilderTest {
	
	@Test
	void build_tables() throws SQLException {
		
		UrlAwareDataSource dataSourceReference = new HSQLDBInMemoryDataSource();
		Connection connection = dataSourceReference.getConnection();
		connection.prepareStatement("create table A(id BIGINT generated by default as identity, name VARCHAR(200) not null, age float, primary key (id));").execute();
		connection.prepareStatement("create table B(id BIGINT, aId BIGINT, dummyData VARCHAR(50), primary key (id));").execute();
		connection.commit();
		
		SchemaBuilder testInstance = new SchemaBuilder(dataSourceReference.getConnection().getMetaData());
		Schema schema = testInstance.withCatalog(null)
				.withSchema(null)
				.withTableNamePattern("%")
				.build();
		
		Schema expectedResult = new Schema(null);
		Table tableA = expectedResult.addTable("A");
		Column columnA_Id = tableA.addColumn("ID", "BIGINT", 64, 0, false, true);
		Column columnA_name = tableA.addColumn("NAME", "VARCHAR", 200, null, false, false);
		Column columnA_age = tableA.addColumn("AGE", "DOUBLE", 64, null, true, false);
		tableA.setPrimaryKey(Arrays.asList(columnA_Id));
		
		Table tableB = expectedResult.addTable("B");
		Column columnB_Id = tableB.addColumn("ID", "BIGINT", 64, 0, false, false);
		Column columnB_aId = tableB.addColumn("AID", "BIGINT", 64, 0, true, false);
		Column columnB_dummyData = tableB.addColumn("DUMMYDATA", "VARCHAR", 50, 0, false, false);
		tableB.setPrimaryKey(Arrays.asList(columnB_Id));
		tableB.addForeignKey("FROMBTOA", Arrays.asList(columnB_aId), tableA, Arrays.asList(columnA_Id));
		
		Index indexToto = expectedResult.new Index("TOTO");
		indexToto.setUnique(true);
		indexToto.addColumn(columnA_name, AscOrDesc.ASC);
		
		BiPredicate<Table, Table> tableNamespacePredicate = Predicates.and(Table::getName, table -> table.getSchema().getName());
		BiPredicate<Column, Column> columnPredicate = Predicates.and(Column::getName, Column::getType, Column::getSize)
				.and((c1, c2) -> tableNamespacePredicate.test(c1.getTable(), c2.getTable()));
		java.util.Comparator<Column> columnComparator = Predicates.toComparator(columnPredicate);
		
		// Checking Table columns, primary key, and other simple attributes
		Map<String, Table> tablePerName = Iterables.map(schema.getTables(), Table::getName);
		Table actualTableA = tablePerName.get("A");
		assertThat(actualTableA.getName()).isEqualTo(tableA.getName());
		assertThat(actualTableA.getComment()).isEqualTo(tableA.getComment());
		assertThat(actualTableA.getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableA.getColumns());
		assertThat(actualTableA.getPrimaryKey().getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableA.getPrimaryKey().getColumns());
		
		Table actualTableB = tablePerName.get("B");
		assertThat(actualTableB.getName()).isEqualTo(tableB.getName());
		assertThat(actualTableB.getComment()).isEqualTo(tableB.getComment());
		assertThat(actualTableB.getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableB.getColumns());
		assertThat(actualTableB.getPrimaryKey().getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableB.getPrimaryKey().getColumns());
		
		assertThat(schema.getTables()).hasSize(2);
	}
		
	@Test
	void build_foreignkeys() throws SQLException {
		
		UrlAwareDataSource dataSourceReference = new HSQLDBInMemoryDataSource();
		Connection connection = dataSourceReference.getConnection();
		connection.prepareStatement("create table A(id BIGINT generated by default as identity, primary key (id));").execute();
		connection.prepareStatement("create table B(id BIGINT, aId BIGINT, primary key (id), constraint fromBtoA foreign key (aId) references A(id));").execute();
		connection.commit();
		
		SchemaBuilder testInstance = new SchemaBuilder(dataSourceReference.getConnection().getMetaData());
		Schema schema = testInstance.withCatalog(null)
				.withSchema(null)
				.withTableNamePattern("%")
				.build();
		
		Schema expectedResult = new Schema(null);
		Table tableA = expectedResult.addTable("A");
		Column columnA_Id = tableA.addColumn("ID", "BIGINT", 64, 0, false, true);
		tableA.setPrimaryKey(Arrays.asList(columnA_Id));
		
		Table tableB = expectedResult.addTable("B");
		Column columnB_Id = tableB.addColumn("ID", "BIGINT", 64, 0, false, false);
		Column columnB_aId = tableB.addColumn("AID", "BIGINT", 64, 0, true, false);
		tableB.setPrimaryKey(Arrays.asList(columnB_Id));
		tableB.addForeignKey("FROMBTOA", Arrays.asList(columnB_aId), tableA, Arrays.asList(columnA_Id));
		
		BiPredicate<Table, Table> tableNamespacePredicate = Predicates.and(Table::getName, table -> table.getSchema().getName());
		BiPredicate<Column, Column> columnPredicate = Predicates.and(Column::getName, Column::getType, Column::getSize)
				.and((c1, c2) -> tableNamespacePredicate.test(c1.getTable(), c2.getTable()));
		java.util.Comparator<Column> columnComparator = Predicates.toComparator(columnPredicate);
		
		// Checking Table columns, primary key, and other simple attributes
		Map<String, Table> tablePerName = Iterables.map(schema.getTables(), Table::getName);
		Table actualTableB = tablePerName.get("B");
		
		// Checking foreign keys
		Map<String, ForeignKey> actualForeignKeyPerName = Iterables.map(actualTableB.getForeignKeys(), ForeignKey::getName);
		ForeignKey actualForeignKeyFromBtoA = actualForeignKeyPerName.get("FROMBTOA");
		Map<String, ForeignKey> currentForeignKeyPerName = Iterables.map(tableB.getForeignKeys(), ForeignKey::getName);
		ForeignKey currentForeignKeyFromBtoA = currentForeignKeyPerName.get("FROMBTOA");
		assertThat(actualForeignKeyFromBtoA.getName()).isEqualTo(currentForeignKeyFromBtoA.getName());
		assertThat(actualForeignKeyFromBtoA.getColumns())
				.usingElementComparator(columnComparator)
				.containsExactlyElementsOf(actualForeignKeyFromBtoA.getColumns());
		assertThat(actualForeignKeyFromBtoA.getTargetTable())
				.usingComparator(Predicates.toComparator(tableNamespacePredicate))
				.isEqualTo(actualForeignKeyFromBtoA.getTargetTable());
		assertThat(actualForeignKeyFromBtoA.getTargetColumns())
				.usingElementComparator(columnComparator)
				.containsExactlyElementsOf(actualForeignKeyFromBtoA.getTargetColumns());
	}
	
	@Test
	void build_indexes() throws SQLException {
		
		UrlAwareDataSource dataSourceReference = new HSQLDBInMemoryDataSource();
		Connection connection = dataSourceReference.getConnection();
		connection.prepareStatement("create table A(id BIGINT generated by default as identity, name VARCHAR(200) not null, age float, primary key (id));").execute();
		connection.prepareStatement("create unique index toto on A(name asc);").execute();
		connection.commit();
		
		SchemaBuilder testInstance = new SchemaBuilder(dataSourceReference.getConnection().getMetaData());
		Schema schema = testInstance.withCatalog(null)
				.withSchema(null)
				.withTableNamePattern("%")
				.build();
	
		Schema expectedResult = new Schema(null);
		Table tableA = expectedResult.addTable("A");
		Column columnA_Id = tableA.addColumn("ID", "BIGINT", 64, 0, false, true);
		Column columnA_name = tableA.addColumn("NAME", "VARCHAR", 200, null, false, false);
		Column columnA_age = tableA.addColumn("AGE", "DOUBLE", 64, null, true, false);
		tableA.setPrimaryKey(Arrays.asList(columnA_Id));
		
		Index indexToto = expectedResult.new Index("TOTO");
		indexToto.setUnique(true);
		indexToto.addColumn(columnA_name, AscOrDesc.ASC);
		
		// Checking indexes
		Map<String, Index> indexPerName = Iterables.map(schema.getIndexes(), Index::getName);
		Index actualIndexToto = indexPerName.get("TOTO");
		assertThat(actualIndexToto.getName()).isEqualTo(indexToto.getName());
		assertThat(actualIndexToto.isUnique()).isEqualTo(indexToto.isUnique());
		
		// Checking columns
		BiPredicate<Table, Table> tableNamespacePredicate = Predicates.and(Table::getName, table -> table.getSchema().getName());
		BiPredicate<Column, Column> columnPredicate = Predicates.and(Column::getName, Column::getType, Column::getSize)
				.and((c1, c2) -> tableNamespacePredicate.test(c1.getTable(), c2.getTable()));
		BiPredicate<Map.Entry<Column, AscOrDesc>, Map.Entry<Column, AscOrDesc>> columnKeyPredicate = (entry1, entry2) -> columnPredicate.test(entry1.getKey(), entry2.getKey());
		columnKeyPredicate = columnKeyPredicate.and(Predicates.and(Entry::getValue));
		assertThat(actualIndexToto.getColumns().entrySet())
				.usingElementComparator(Predicates.toComparator(columnKeyPredicate.and(Predicates.and(Entry::getValue))))
				.containsExactlyElementsOf(indexToto.getColumns().entrySet());
	}
	
	@Test
	void build_views() throws SQLException {
		
		UrlAwareDataSource dataSourceReference = new HSQLDBInMemoryDataSource();
		Connection connection = dataSourceReference.getConnection();
		connection.prepareStatement("create table A(id BIGINT generated by default as identity, name VARCHAR(200) not null, age float, primary key (id));").execute();
		connection.prepareStatement("create table B(id BIGINT, aId BIGINT, dummyData VARCHAR(50), primary key (id), constraint fromBtoA foreign key (aId) references A(id));").execute();
		connection.prepareStatement("create view DummyView as select a.id as x, a.name, b.dummyData from A a inner join B b on a.id = b.aId;").execute();
		connection.commit();
		
		SchemaBuilder testInstance = new SchemaBuilder(dataSourceReference.getConnection().getMetaData());
		Schema schema = testInstance.withCatalog(null)
				.withSchema(null)
				.withTableNamePattern("%")
				.build();
	
		// Checking views
		Schema expectedResult = new Schema(null);
		View tutuView = expectedResult.addView("DUMMYVIEW");
		tutuView.addColumn("X", "BIGINT", 64, 0, true)
				// note that NAME column is nullable in view whereas it's not in original table
				.addColumn("NAME", "VARCHAR", 200, null, true)
				.addColumn("DUMMYDATA", "VARCHAR", 50, null, true);
		
		Map<String, View> viewPerName = Iterables.map(schema.getViews(), View::getName);
		View actualView = viewPerName.get("DUMMYVIEW");
		assertThat(actualView.getName()).isEqualTo(tutuView.getName());
		
		BiPredicate<PseudoColumn, PseudoColumn> columnPredicate = Predicates.and(PseudoColumn::getName, PseudoColumn::getType,
						PseudoColumn::getSize, PseudoColumn::getPrecision, PseudoColumn::isNullable);
		java.util.Comparator<PseudoColumn> columnComparator = Predicates.toComparator(columnPredicate);
		assertThat(actualView.getColumns())
				.usingElementComparator(columnComparator)
				.containsExactlyElementsOf(tutuView.getColumns());
	}
	
	@Test
	void build() throws SQLException {
		
		DataSource dataSourceReference = new HSQLDBInMemoryDataSource();
		Connection connection = dataSourceReference.getConnection();
		connection.prepareStatement("create table A(id BIGINT generated by default as identity, name VARCHAR(200) not null, age float, primary key (id));").execute();
		connection.prepareStatement("create table B(id BIGINT, aId BIGINT, dummyData VARCHAR(50), primary key (id), constraint fromBtoA foreign key (aId) references A(id));").execute();
		connection.prepareStatement("create unique index toto on A(name asc);").execute();
		connection.prepareStatement("create view TUTU as select a.id, a.name, b.dummyData from A a inner join B b on a.id = b.aId;").execute();
		connection.commit();
		
		SchemaBuilder testInstance = new SchemaBuilder(dataSourceReference.getConnection().getMetaData());
		testInstance.withCatalog(null)
				.withSchema(null)
				.withTableNamePattern("%");
		Schema schema = testInstance.build();
	
		Schema expectedResult = new Schema(null);
		Table tableA = expectedResult.addTable("A");
		Column columnA_Id = tableA.addColumn("ID", "BIGINT", 64, 0, false, true);
		Column columnA_name = tableA.addColumn("NAME", "VARCHAR", 200, null, false, false);
		Column columnA_age = tableA.addColumn("AGE", "DOUBLE", 64, null, true, false);
		tableA.setPrimaryKey(Arrays.asList(columnA_Id));
		
		Table tableB = expectedResult.addTable("B");
		Column columnB_Id = tableB.addColumn("ID", "BIGINT", 64, 0, false, false);
		Column columnB_aId = tableB.addColumn("AID", "BIGINT", 64, 0, true, false);
		Column columnB_dummyData = tableB.addColumn("DUMMYDATA", "VARCHAR", 50, 0, false, false);
		tableB.setPrimaryKey(Arrays.asList(columnB_Id));
		tableB.addForeignKey("FROMBTOA", Arrays.asList(columnB_aId), tableA, Arrays.asList(columnA_Id));
		
		Index indexToto = expectedResult.new Index("TOTO");
		indexToto.setUnique(true);
		indexToto.addColumn(columnA_name, AscOrDesc.ASC);
		
		assertThat(schema.getName()).isNull();
		
		BiPredicate<Table, Table> tableNamespacePredicate = Predicates.and(Table::getName, table -> table.getSchema().getName());
		BiPredicate<Column, Column> columnPredicate = Predicates.and(Column::getName, Column::getType, Column::getSize)
				.and((c1, c2) -> tableNamespacePredicate.test(c1.getTable(), c2.getTable()));
		java.util.Comparator<Column> columnComparator = Predicates.toComparator(columnPredicate);
		
		// Checking Table columns, primary key, and other simple attributes
		Map<String, Table> tablePerName = Iterables.map(schema.getTables(), Table::getName);
		Table actualTableA = tablePerName.get("A");
		assertThat(actualTableA.getName()).isEqualTo(tableA.getName());
		assertThat(actualTableA.getComment()).isEqualTo(tableA.getComment());
		assertThat(actualTableA.getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableA.getColumns());
		assertThat(actualTableA.getPrimaryKey().getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableA.getPrimaryKey().getColumns());
		
		Table actualTableB = tablePerName.get("B");
		assertThat(actualTableB.getName()).isEqualTo(tableB.getName());
		assertThat(actualTableB.getComment()).isEqualTo(tableB.getComment());
		assertThat(actualTableB.getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableB.getColumns());
		assertThat(actualTableB.getPrimaryKey().getColumns()).usingElementComparator(columnComparator).containsExactlyElementsOf(tableB.getPrimaryKey().getColumns());
		
		assertThat(schema.getTables()).hasSize(2);
		
		// Checking foreign keys
		Map<String, ForeignKey> actualForeignKeyPerName = Iterables.map(actualTableB.getForeignKeys(), ForeignKey::getName);
		ForeignKey actualForeignKeyFromBtoA = actualForeignKeyPerName.get("FROMBTOA");
		Map<String, ForeignKey> currentForeignKeyPerName = Iterables.map(tableB.getForeignKeys(), ForeignKey::getName);
		ForeignKey currentForeignKeyFromBtoA = currentForeignKeyPerName.get("FROMBTOA");
		assertThat(actualForeignKeyFromBtoA.getName()).isEqualTo(currentForeignKeyFromBtoA.getName());
		assertThat(actualForeignKeyFromBtoA.getColumns())
				.usingElementComparator(columnComparator)
				.containsExactlyElementsOf(actualForeignKeyFromBtoA.getColumns());
		assertThat(actualForeignKeyFromBtoA.getTargetTable())
				.usingComparator(Predicates.toComparator(tableNamespacePredicate))
				.isEqualTo(actualForeignKeyFromBtoA.getTargetTable());
		assertThat(actualForeignKeyFromBtoA.getTargetColumns())
				.usingElementComparator(columnComparator)
				.containsExactlyElementsOf(actualForeignKeyFromBtoA.getTargetColumns());
		
		// Checking indexes
		BiPredicate<Map.Entry<Column, AscOrDesc>, Map.Entry<Column, AscOrDesc>> columnKeyPredicate = (entry1, entry2) -> columnPredicate.test(entry1.getKey(), entry2.getKey());
		columnKeyPredicate = columnKeyPredicate.and(Predicates.and(Entry::getValue));
		Map<String, Index> indexPerName = Iterables.map(schema.getIndexes(), Index::getName);
		Index actualIndexToto = indexPerName.get("TOTO");
		assertThat(actualIndexToto.getName()).isEqualTo(indexToto.getName());
		assertThat(actualIndexToto.isUnique()).isEqualTo(indexToto.isUnique());
		assertThat(actualIndexToto.getColumns().entrySet())
				.usingElementComparator(Predicates.toComparator(columnKeyPredicate.and(Predicates.and(Entry::getValue))))
				.containsExactlyElementsOf(indexToto.getColumns().entrySet());
	}
	
	@Test
	void build_difference() throws SQLException {
		
		UrlAwareDataSource dataSource = new HSQLDBInMemoryDataSource();
		Connection connection1 = dataSource.getConnection();
		connection1.prepareStatement("create schema REFERENCE").execute();
		connection1.prepareStatement("set schema REFERENCE").execute();
		connection1.prepareStatement("create table A(id BIGINT generated by default as identity, name VARCHAR(200) not null, age float, primary key (id));").execute();
		connection1.prepareStatement("create table B(id BIGINT, aId BIGINT, dummyData VARCHAR(50), primary key (id), constraint fromBtoA foreign key (aId) references A(id));").execute();
		connection1.prepareStatement("create table C(id BIGINT, aId BIGINT, lastname VARCHAR(50), primary key (id), constraint fromCtoA foreign key (aId) references A(id));").execute();
		connection1.prepareStatement("create table D(firstname VARCHAR(50));").execute();
		connection1.prepareStatement("create unique index toto on A(name asc);").execute();
		connection1.prepareStatement("create unique index tata on C(lastname desc);").execute();
		connection1.prepareStatement("create view TUTU as select a.id, a.name, b.dummyData from A a inner join B b on a.id = b.aId;").execute();
		connection1.commit();
		connection1.close();
		
		Connection connection2 = dataSource.getConnection();
		connection2.prepareStatement("create schema COMPARISON").execute();
		connection2.prepareStatement("set schema COMPARISON").execute();
		connection2.prepareStatement("create table A(id BIGINT generated by default as identity, name VARCHAR(200) not null, age float, primary key (id));").execute();
		connection2.prepareStatement("create table B(id BIGINT, aId BIGINT, dummyData VARCHAR(50), primary key (id), constraint fromBtoA foreign key (aId) references A(id));").execute();
		connection2.prepareStatement("create table C(id BIGINT, aId BIGINT, lastname VARCHAR(50), primary key (id));").execute();
		connection2.prepareStatement("create unique index tata on C(lastname asc);").execute();
		connection2.prepareStatement("create view TUTU as select a.id, a.name, b.dummyData from A a inner join B b on a.id = b.aId;").execute();
		connection2.commit();
		connection2.close();
		
		SchemaBuilder testInstance = new SchemaBuilder(dataSource.getConnection().getMetaData());
		testInstance.withCatalog(null)
				.withSchema("REFERENCE")
				.withTableNamePattern("%");
		Schema ddlElements1 = testInstance.build();
		
		testInstance.withCatalog(null)
				.withSchema("COMPARISON")
				.withTableNamePattern("%");
		Schema ddlElements2 = testInstance.build();
		
		SetDiffer<Table, String> tableCollectionDiffer = new SetDiffer<>(Table::getName);
		Set<Diff<Table>> tableDiffs = tableCollectionDiffer.diff(ddlElements1.getTables(), ddlElements2.getTables());
		tableDiffs.stream().filter(d -> d.getState() == State.ADDED).forEach(d -> {
			System.out.println("Unexpected table " + d.getReplacingInstance().getName());
		});
		tableDiffs.stream().filter(d -> d.getState() == State.REMOVED).forEach(d -> {
			System.out.println("Missing table " + d.getSourceInstance().getName());
		});
		
		ListDiffer<Column> columnCollectionDiffer = new ListDiffer<>(Column::getName);
		tableDiffs.stream().filter(d -> d.getState() == State.HELD).forEach(d -> {
			KeepOrderSet<IndexedDiff<Column>> columnDiffs = columnCollectionDiffer.diff(d.getSourceInstance().getColumns(), d.getReplacingInstance().getColumns());
			columnDiffs.stream().filter(g -> g.getState() == State.ADDED).forEach(g -> {
				System.out.println("Unexpected column " + g.getReplacingInstance().getTable().getName() + "." + g.getReplacingInstance().getName());
			});
			columnDiffs.stream().filter(g -> g.getState() == State.REMOVED).forEach(g -> {
				System.out.println("Missing column " + g.getSourceInstance().getTable().getName() + "." + g.getSourceInstance().getName());
			});
		});
		
		ComparisonChain<Schema>.CollectionComparisonChain<Index, Set<Index>> comparisonChain = comparisonChain(Schema.class)
				.compareOn(Schema::getTables, Table::getName)
				.thenForeachHeld(comparisonChain(Table.class)
						.compareOn(Table::getComment)
						.compareOn(Table::getColumns, Column::getName)
						.thenForeachHeld(comparisonChain(Column.class)
								.compareOn(Column::getType)))
				.compareOn(Schema::getIndexes, Index::getName);
		
		Set<AbstractDiff<?>> diffs = comparisonChain.run(ddlElements1, ddlElements2);
		
		System.out.println("----------------------------------------------------------");
		
		System.out.println("Added in " + dataSource.getUrl());
		diffs.stream().filter(d -> d.getState() == State.ADDED).forEach(d -> {
			System.out.println(d.getReplacingInstance());
		});
		System.out.println("Modifications between " + dataSource.getUrl() + " and " +dataSource.getUrl());
		diffs.stream().filter(d -> d.getState() == State.HELD).forEach(d -> {
			if (d instanceof PropertyComparator.PropertyDiff) {
				String propertyName = AccessorDefinition.giveDefinition(new AccessorByMethodReference<>(((PropertyDiff<?, ?>) d).getPropertyAccessor())).getName();
				System.out.println(propertyName +": " + d.getSourceInstance() + " vs " + d.getReplacingInstance());
			}
		});
		System.out.println("Missing in " + dataSource.getUrl());
		diffs.stream().filter(d -> d.getState() == State.REMOVED).forEach(d -> {
			System.out.println(d.getSourceInstance());
		});
	}
	
	<T> ComparisonChain<T> comparisonChain(Class<T> clazz) {
		return new ComparisonChain<>(clazz);
	}
	
	public static class ComparisonChain<T> {
		
		private final Class<T> comparedType;
		
		private final List<Object> propertiesToCompare = new ArrayList<>();
		
		public ComparisonChain(Class<T> comparedType) {
			this.comparedType = comparedType;
		}
		
		public <E, C extends Collection<E>> CollectionComparisonChain<E, C> compareOn(Function<T, C> collectionAccessor, Function<E, ?> keyAccessor) {
			CollectionComparisonChain<E, C> collectionComparison = new CollectionComparisonChain<>(collectionAccessor, keyAccessor);
			this.propertiesToCompare.add(collectionComparison);
			return collectionComparison;
		}
		
		public <O> ComparisonChain<T> compareOn(SerializableFunction<T, O> propertyAccessor) {
			this.propertiesToCompare.add(new PropertyComparator<>(propertyAccessor, Objects::equals));
			return this;
		}
		
		public Set<AbstractDiff<?>> run(T t1, T t2) {
			Set<AbstractDiff<?>> result = new HashSet<>();
			propertiesToCompare.forEach(p -> {
				if (p instanceof ComparisonChain.CollectionComparisonChain) {
					Set<AbstractDiff<T>> compare = ((CollectionComparisonChain) p).collectionComparator.compare(t1, t2);
					if (!compare.isEmpty()) {
						result.addAll(compare.stream()
								.filter(d -> d.getState() != State.HELD).collect(Collectors.toList()));
						ComparisonChain next = ((CollectionComparisonChain) p).next;
						if (next != null) {
							List<AbstractDiff<?>> collect = compare.stream()
									.filter(d -> d.getState() == State.HELD)
									.map(d -> next.run(d.getSourceInstance(), d.getReplacingInstance()))
									.flatMap(Set<AbstractDiff<?>>::stream)
									.collect(Collectors.toList());
							result.addAll(collect);
						}
					}
				} else if (p instanceof ComparisonChain.PropertyComparator) {
					AbstractDiff diff = ((PropertyComparator) p).compare(t1, t2);
					if (diff != null) {
						result.add(diff);
					}
				}
			});
			return result;
		}
		
		private class CollectionComparisonChain<E, C extends Collection<E>> {
			
			private final CollectionComparator<T, E, C> collectionComparator;
			private ComparisonChain<?> next;
			
			private CollectionComparisonChain(Function<T, C> collectionAccessor, Function<E, ?> keyAccessor) {
				this.collectionComparator = new CollectionComparator<>(collectionAccessor, keyAccessor);
			}
			
			public ComparisonChain<T> thenForeachHeld(ComparisonChain<?> next) {
				this.next = next;
				return ComparisonChain.this;
			}
			
			public Set<AbstractDiff<?>> run(T ddlElements1, T ddlElements2) {
				return ComparisonChain.this.run(ddlElements1, ddlElements2);
			}
		}
		
		static class CollectionComparator<T, E, C extends Collection<E>> {
			
			private final Function<T, C> collectionAccessor;
			private final Function<E, ?> keyAccessor;
			
			private CollectionComparator(Function<T, C> collectionAccessor, Function<E, ?> keyAccessor) {
				this.keyAccessor = keyAccessor;
				this.collectionAccessor = collectionAccessor;
			}
			
			Set<AbstractDiff<E>> compare(T t1, T t2) {
				CollectionDiffer<E, C, AbstractDiff<E>> collectionDiffer = null;
				C apply = collectionAccessor.apply(t1);
				if (apply instanceof Set) {
					collectionDiffer = (CollectionDiffer) new SetDiffer<>(keyAccessor);
				} else if (apply instanceof List) {
					collectionDiffer = (CollectionDiffer) new ListDiffer<>(keyAccessor);
				}
				C apply1 = collectionAccessor.apply(t2);
				return collectionDiffer.diff(apply, apply1);
			}
		}
		
		/**
		 * Comparator of a property between 2 objects of same type
		 *
		 * @param <T> object type
		 * @param <O> property value type
		 * @author Guillaume Mary
		 */
		static class PropertyComparator<T, O> {
			
			private final SerializableFunction<T, O> propertyAccessor;
			
			private final BiPredicate<O, O> predicate;
			
			private PropertyComparator(SerializableFunction<T, O> propertyAccessor, BiPredicate<O, O> predicate) {
				this.propertyAccessor = propertyAccessor;
				this.predicate = predicate;
			}
			
			AbstractDiff<T> compare(T t1, T t2) {
				O v1 = propertyAccessor.apply(t1);
				O v2 = propertyAccessor.apply(t2);
				boolean comparison = predicate.test(v1, v2);
				if (!comparison) {
					return new PropertyDiff<>(propertyAccessor, t1, t2);
				}
				return null;
			}
			
			/**
			 * Storage of a property difference between 2 objects of same type
			 *
			 * @param <T> object type
			 * @param <O> property value type
			 * @author Guillaume Mary
			 */
			static class PropertyDiff<T, O> extends AbstractDiff<T> {
				
				private final SerializableFunction<T, O> propertyAccessor;
				
				/**
				 * Minimal constructor.
				 *
				 * @param sourceInstance initial instance
				 * @param replacingInstance replacing instance (may differ from source on attributes except id)
				 */
				public PropertyDiff(SerializableFunction<T, O> propertyAccessor, T sourceInstance, T replacingInstance) {
					super(State.HELD, sourceInstance, replacingInstance);
					this.propertyAccessor = propertyAccessor;
				}
				
				public SerializableFunction<T, ?> getPropertyAccessor() {
					return propertyAccessor;
				}
			}
		}
	}
}