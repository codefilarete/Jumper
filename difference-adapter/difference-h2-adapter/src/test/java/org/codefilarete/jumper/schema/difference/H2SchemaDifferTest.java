package org.codefilarete.jumper.schema.difference;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.codefilarete.jumper.schema.DefaultSchemaElementCollector;
import org.codefilarete.jumper.schema.DefaultSchemaElementCollector.Schema;
import org.codefilarete.jumper.schema.DefaultSchemaElementCollector.Schema.Index;
import org.codefilarete.jumper.schema.DefaultSchemaElementCollector.Schema.Table;
import org.codefilarete.jumper.schema.DefaultSchemaElementCollector.Schema.Table.Column;
import org.codefilarete.jumper.schema.difference.SchemaDiffer.ComparisonChain.PropertyComparator;
import org.codefilarete.jumper.schema.difference.SchemaDiffer.ComparisonChain.PropertyComparator.PropertyDiff;
import org.codefilarete.reflection.AccessorByMethodReference;
import org.codefilarete.reflection.AccessorDefinition;
import org.codefilarete.stalactite.sql.UrlAwareDataSource;
import org.codefilarete.stalactite.sql.test.H2InMemoryDataSource;
import org.codefilarete.tool.bean.Randomizer;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

class H2SchemaDifferTest {
	
	@Test
	void compare() throws SQLException {
        String databaseName = Randomizer.INSTANCE.randomHexString(8);
        UrlAwareDataSource dataSource = new H2InMemoryDataSource(databaseName);
		Connection connection1 = dataSource.getConnection();
		connection1.prepareStatement("create schema REFERENCE").execute();
		connection1.prepareStatement("set schema REFERENCE").execute();
		connection1.prepareStatement("create table A(id BIGINT generated by default as identity, name VARCHAR(200) not null, age float, primary key (id))").execute();
		connection1.prepareStatement("create table B(id BIGINT, aId BIGINT, dummyData VARCHAR(50), primary key (id), constraint fromBtoA foreign key (aId) references A(id))").execute();
		connection1.prepareStatement("create table C(id BIGINT, aId BIGINT, lastname VARCHAR(50), primary key (id), constraint fromCtoA foreign key (aId) references A(id))").execute();
		connection1.prepareStatement("create table D(firstname VARCHAR(50))").execute();
		connection1.prepareStatement("create unique index toto on A(name asc)").execute();
		connection1.prepareStatement("create unique index tata on C(lastname desc)").execute();
		connection1.prepareStatement("create view TUTU as select a.id, a.name, b.dummyData from A a inner join B b on a.id = b.aId").execute();
		connection1.commit();
		// Note that we shall not close the connection else we loose everything done during this session !
		// (it doesn't appear at all afterward, strange behavior from H2)
		
		Connection connection2 = dataSource.getConnection();
		connection2.prepareStatement("create schema COMPARISON").execute();
		connection2.prepareStatement("set schema COMPARISON").execute();
		connection2.prepareStatement("create table A(id BIGINT generated by default as identity, name VARCHAR(200) not null, age float, primary key (id))").execute();
		connection2.prepareStatement("create table B(id BIGINT, aId BIGINT, dummyData VARCHAR(50), primary key (id), constraint fromBtoA foreign key (aId) references A(id))").execute();
		connection2.prepareStatement("create table C(id BIGINT, aId BIGINT, firstname VARCHAR(50), lastname VARCHAR(100), primary key (id))").execute();
		connection2.prepareStatement("create table E(firstname VARCHAR(50))").execute();
		connection2.prepareStatement("create index tata on C(lastname asc)").execute();
		connection2.prepareStatement("create view TUTU as select a.id, a.name, b.dummyData from A a inner join B b on a.id = b.aId").execute();
		connection2.commit();
		// Note that we shall not close the connection else we loose everything done during this session !
		// (it doesn't appear at all afterward, strange behavior from H2)
		
		DefaultSchemaElementCollector schemaElementCollector = new DefaultSchemaElementCollector(dataSource.getConnection().getMetaData());
		schemaElementCollector.withCatalog(null)
				.withSchema("REFERENCE")
				.withTableNamePattern("%");
		Schema ddlElements1 = schemaElementCollector.collect();
		
		schemaElementCollector.withCatalog(null)
				.withSchema("COMPARISON")
				.withTableNamePattern("%");
		Schema ddlElements2 = schemaElementCollector.collect();
		
		SchemaDiffer testInstance = new H2SchemaDiffer();
		Set<AbstractDiff<?>> diffs = testInstance.compare(ddlElements1, ddlElements2);
		
		// Elements added in "COMPARISON" schema
		assertThat(diffs.stream().filter(d -> d.getState() == State.ADDED)).map(diff -> diff.getReplacingInstance().toString())
				.containsExactlyInAnyOrder(
						"Table{name='E'}",
						"Column{tableName='C', name='FIRSTNAME', type='VARCHAR', size=50, scale=0, nullable=true}"
				);
		
		// Modifications between in "REFERENCE" and "COMPARISON" schemas
		assertThat(diffs.stream().filter(d -> d.getState() == State.HELD).filter(PropertyDiff.class::isInstance).map(PropertyDiff.class::cast)
				.map(propertyDiff -> {
					AccessorDefinition accessorDefinition = AccessorDefinition.giveDefinition(new AccessorByMethodReference<>(((PropertyDiff<?, ?>) propertyDiff).getPropertyAccessor()));
					String propertyName = accessorDefinition.getName();
					return accessorDefinition.getDeclaringClass().getSimpleName() + "." + propertyName + ": "
							+ propertyDiff.getSourceInstance() + " vs " + propertyDiff.getReplacingInstance();
				})).containsExactlyInAnyOrder(
                "Schema.name: Schema{name='" + databaseName + ".REFERENCE'} vs Schema{name='" + databaseName + ".COMPARISON'}",
				"Index.unique: Index{name='TATA', table='C', unique=true, columns={'LASTNAME'}} vs Index{name='TATA', table='C', unique=false, columns={'LASTNAME'}}",
				"Column.size: Column{tableName='C', name='LASTNAME', type='VARCHAR', size=50, scale=0, nullable=true} vs Column{tableName='C', name='LASTNAME', type='VARCHAR', size=100, scale=0, nullable=true}",
				"IndexedColumn.direction: IndexedColumn{index=TATA, column=LASTNAME, direction=DESC} vs IndexedColumn{index=TATA, column=LASTNAME, direction=ASC}"
		);
		
		// Missing elements in "COMPARISON" schema
		assertThat(diffs.stream().filter(d -> d.getState() == State.REMOVED)).map(diff -> diff.getSourceInstance().toString())
				.containsExactlyInAnyOrder(
						"Table{name='D'}",
						"Index{name='FROMCTOA_INDEX_4', table='C', unique=false, columns={'AID'}}",
						"Index{name='TOTO', table='A', unique=true, columns={'NAME'}}"
				);
		
		connection1.close();
		connection2.close();
	}
	
}